<?xml version="1.0"?>

<!--
	description:

		"Structure of the Traffic 3D front end documentation"

	copyright: ""
	license: ""
	date: "$Date:"
	revision: "$Revision:"
-->

<chapter xmlns="http://www.gobosoft.com/eiffel/gobo/documentation" id="sample/with_code">
<chapterinfo>
	<copyright>
		<year>2005</year>
		<holder>David Stefan, Valentin Wüstholz</holder>
	</copyright>
	<author>
		<firstname>David</firstname><surname>Stefan</surname>
	</author>
    <author>
		<firstname>Valentin</firstname><surname>Wüstholz</surname>
	</author>
	<!--<email>bay@inf.ethz.ch</email>-->
	<date>12. September 2005</date>
</chapterinfo>

<title>Structure of the project</title>
<section id="page_index">
<title>Page Index</title>
<para>
<itemizedlist>
    <listitem><para>
    	<indexlink url="#scene">CITY_3D_SCENE</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#map">MAP</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#building_ewer">BUILDING_EWER</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#shared_constants">SHARED_CONSTANTS</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#factories">Factories:</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#traffic_line_factory">TRAFFIC_LINE_FACTORY</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#building_factory">BUILDING_FACTORY</indexlink>
    </para></listitem>
     <listitem><para>
    	<indexlink url="#utilities">Utilities:</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#gl_vector">GL_VECTOR</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#gl_light">GL_LIGHT</indexlink>
    </para></listitem>
</itemizedlist>
</para>
</section>

<section id="scene">
	<para/>
	<title>CITY_3D_SCENE</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	An instance of <classname>CITY_3D_SCENE</classname> gets created by the root class and called using the standard EM procedure. 
	It uses the widget toolkit of the EM library to display a panel for the OpenGL visualization of the map and another one used as a toolbar for the different options.
	</para>
	<title>Creation procedure</title>
	<para>
	The creation procedure of the class creates all the needed widgets, such as checkboxes, slidebars or labels, and specifies their position, color 
	and properties. If necessary, it subscribes a feature in the appropriate event handler.
	Moreover, it creates an instance of the <classname>MAP</classname> class, which is responsible for all the things that have to be done in order to visualize the map.
	</para>
	<title>Event handling</title>
	<para>
	The event handling of this class is very important as it is the link between the user input and the features of the <classname>MAP</classname> class that do the necessary 
	operations such that the visual effects take place.
	It is important to notice that the instance of the <classname>MAP</classname> class doesn't know it's scene and therefore commands are only 
	given from the scene to the map. If the map has to process information to the scene, such as the name of a marked point, the scene has to subscribe 
	to the event handler of the map and query the desired information.
	</para>
<toplink/>
</section>

<section id="map">
	<para/>
	<title>MAP</title>
	<para>
	</para>
	<title>Description</title>
	<para>
    This is the main class of the project and has three main tasks. First provides features for parsing the map XML file. Then it manages the whole drawing process. This includes creating the necessary factories and drawing the map according to the enabled options. Last but not least it handles the user input. This means it has event handlers that change properties like zooming, translation or rotation.
	</para>
	<title>Event handling</title>
	<para>
	 i) Mouse wheel:
	Controls the zooming factor, whereas the position stays invariant. There are two different zooming speeds depending on the distance to the plane.
	</para>
	<para>
	 ii) Mouse click:
	Is used to mark stations on the map. The origin can be marked with the left mouse button, the destination with the right one. If the user clicks on an empty spot,
	the marked stations are revoked.
	</para>
	<para>
	 iii) Mouse dragging:
        <itemizedlist>
            <listitem><para>
                Left mouse button: By dragging the mouse while pressing the left button one is able to translate the position of the map in the window, i.e.
		move the plane.
            </para></listitem>
            <listitem><para>
                Right mouse button: By dragging the mouse while pressing the right button one is able to rotate the map around the the origin.
            </para></listitem>
        </itemizedlist>
	</para>
	<para>
	 iv) Keyboard:
        <itemizedlist>
            <listitem><para>
                By pressing the up-/down- or left-/right- arrow keys the map will be rotated around the x- or y-axis respectively.
            </para></listitem>
            <listitem><para>
                By pressing the enter key the translation will be reset to its initial value. However, zoom as well as rotation aren't affected.
            </para></listitem>
        </itemizedlist>
	</para>
	<title>Options</title>
	<para>
	 i) Show a coordinate system: This shows a coordinate system at the origin for better orientation.
	 </para>
	<para>
	 ii) Change lighting of the map: Initially, the scene is lit by a constant light coming down the y axis. 
	 However, this can be changed to a variable light that tries to imitates the effect of the sun.
    </para>
	<para>
	 iii) Change the number of buildings to be displayed on the map: The number of buildings can be varied from 150 up to 15000. 
	 They are randomly distributed using an instance of class <classname>BUILDING_EWER</classname>.
    </para>
	<para>
	 iv) Highlight the traffic lines by drawing them with different height on the map, in order to achieve a better overview.
    </para>
	<para>
	 v) Show the shortest path between two marked stations and display it as a white line.
    </para>
	<para>
	 vi) Make the buildings transparent in order to achieve a better overview.
	</para>
<toplink/>
</section>

<section id="building_ewer">
	<para/>
	<title>BUILDING_EWER</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	The class <classname>BUILDING_EWER</classname> is responsible for distributing buildings on the plane.
	It takes the number of buildings from the map object and places the according number 
	of buildings on the plane using a random number generator and a collision detection, 
	which checks for collisions with traffic lines. It stores the created objects (buildings) in a container 
	and provides a feature to the map object that does the necessary drawing.
	</para>
	<title>Building distribution</title>
	<para>
	First, the centre of the new building is calculated using the random number generator. 
	Next, the collision polygon is created using these coordinates. Then the feature <featurename>has_collision</featurename>
	checks for collisions with the polygons of the traffic lines that have been created earlier in the creation procedure. 
	If there're any collisions, the coordinates are discarded and new ones calculated. If not, the distance to the centre is calculated 
	and depending on this distance a different form and height of the building is chosen. Finally, the building is set to the 
	right position and put into the container where it is stored. 
	</para>
	<title>Adding buildings</title>
	<para>
	If the slidebar is moved and additional buildings have to be displayed, <featurename>set_building_number</featurename>
	calculates how many and calls <featurename>add_buildings</featurename>, which takes the random number generator and the 
	container of the buildings that have already been created and adds the difference to it. Similarly, if less buildings should be displayed, 
	i.e. the slidebar is moved left, the container stays the same and only the feature <featurename>draw</featurename>, 
	which is essentially a loop over the container and a draw call to all the items, is changed by setting 
	a new upper limit.
	</para>
	<toplink/>
</section>

<section id="shared_constants">
	<para/>
	<title>SHARED_CONSTANTS</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	The intention of this class is to collect information that would be spread over the whole project otherwise. 
	This helps adjusting the project and makes minor changes easier, as a constant (like <featurename>line_width</featurename>) only has to be changed a single time to take effects on the whole project. 
	All classes that want to use constants or procedures from <classname>SHARED_CONSTANTS</classname> inherit from this class, 
	but do not export the inherited features so that they are not visible in the interface.
	</para>
	<title>Constants</title>
	<para>
	In addition to constants of minor importance, such as line-/window- height and width, the most important one is <featurename>plane_size</featurename> which is used 
	mostly in the classes <classname>MAP</classname> and <classname>BUILDING_EWER</classname> for calculations related to the 
	distribution of buildings and other issues.
	</para>
	<title>map_to_gl_coords</title>
	<para>
	This query is of great importance to the project as it maps the coordinates in the XML files that vary from 0 to 1500 to the coordinates of the plane, 
	which are in the range of -plane_size/2 to +plane_size/2. 
	All coordinate transformations that have to be done call this procedure. This makes an adjustment to new coordinates in an XML file pretty easy, 
	because only this feature would have to be changed.
	</para>
	<toplink/>
</section>

<section id="factories">
	<para/>
	<title>Factories:</title>
	<para>
	</para>
</section>
	
<section id="traffic_line_factory">
	<para>
	</para>
	<title>TRAFFIC_LINE_FACTORY</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	This class is a factory for creating displayable representations of <classname>TRAFFIC_LINE</classname> objects. 
	It inherits from <classname>EM_3D_OBJECT_FACTORY</classname> which provides the necessary structures such as the feature <featurename>create_object</featurename> or <featurename>specify_object</featurename>. <featurename>specify_object</featurename> contains the (OpenGL) commands to create the object and has to be implemented.
	</para>
	<title>Building a line</title>
	<para>
	Each line segment is drawn independently, putting a circle at the beginning and the end to indicate that 
	there are stations. Next, the 'polypoints' list is traversed and for each two points a rectangle of 
	width <featurename>line_width</featurename> is created. These rectangles are connected with circles again, but smaller as the ones representing the stations.
	</para>
	<toplink/>
</section>

<section id="building_factory">
	<para/>
	<title>BUILDING_FACTORY</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	Similarly to <classname>TRAFFIC_LINE_FACTORY</classname>, this class is responsible for creating new buildings 
	and stores the information about the type of building, such as central or outlying. 
	</para>
	<title>Type of buildings</title>
	<para>
	There are three different kinds of buildings implemented: city_centre, central and outlying. City_centre is the most central kind and its buildings consist of a cylinder with a hemisphere on top of it. 
	Central consists of cubes with the same size as the ones that are used for outlying, but with a pyramid roof.
	As said before, the third and last kind, outlying, only contains mere cubes.
	</para>
	<toplink/>
</section>

<section id="utilities">
	<para/>
	<title>Utilities:</title>
	<para>
	</para>
</section>

<section id="gl_vector">
	<para/>
	<title>GL_VECTOR</title>
    <para>
	</para>
	<para>
	The <classname>GL_VECTOR_3D</classname> and <classname>GL_VECTOR_4D</classname> functions are pretty 
	neat in order to pass vectors in a feature call, because they can be directly passed to the OpenGL procedures. Moreover, this simplifies the source code.
	</para>
    <toplink/>
</section>

<section id="gl_light">
	<para/>
	<title>GL_LIGHT</title>
    <para>
	</para>
	<para>
	<classname>GL_LIGHT</classname> is another class that comes in pretty handy, because it embeds all the information that is needed 
	to create and change a light source for a scene. Instead of calling the appropriate OpenGL procedures directly, when the position or color of a 
	light has to be changed, the according feature of this class is called. This avoids calling the same OpenGL functions again and again and gives 
	the whole thing an object orientated touch.
	</para>
	<toplink/>
</section>
</chapter>
