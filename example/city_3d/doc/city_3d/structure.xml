<?xml version="1.0"?>

<!--
	description:

		"Structure of Traffic 3D front end documentation"

	copyright: ""
	license: ""
	date: "$Date:"
	revision: "$Revision:"
-->

<chapter xmlns="http://www.gobosoft.com/eiffel/gobo/documentation" id="sample/with_code">
<chapterinfo>
	<copyright>
		<year>2005</year>
		<holder>David Stefan, Valentin Wüstholz</holder>
	</copyright>
	<author>
		<firstname>David</firstname><surname>Stefan</surname>
	</author>
    <author>
		<firstname>Valentin</firstname><surname>Wüstholz</surname>
	</author>
	<!--<email>bay@inf.ethz.ch</email>-->
	<date>12. September 2005</date>
</chapterinfo>

<title>Structure of project</title>
<section id="page_index">
<title>Page Index</title>
<para>
<itemizedlist>
    <listitem><para>
    	<indexlink url="#scene">CITY_3D_SCENE</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#map">MAP</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#factories">Factories:</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#line_factory">TRAFFIC_LINE_FACTORY</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#building_factory">BUILDING_FACTORY</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#building_ewer">BUILDING_EWER</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#shared_constants">SHARED_CONSTANTS</indexlink>
    </para></listitem>
     <listitem><para>
    	<indexlink url="#utilities">Utilities:</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#gl_vector">GL_VECTOR</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#gl_light">GL_LIGHT</indexlink>
    </para></listitem>
</itemizedlist>
</para>
</section>

<section id="scene">
	<para>
	</para>
	<title>CITY_3D_SCENE</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	An instance of <classname>CITY_3D_SCENE</classname> gets created by the root class and called using the standard EM procedure. 
	It uses the widget toolkit of the EM library to display a panel for the OpenGL visualization of the map and another one used as a toolbar for the different options.
	</para>
	<title>Creation procedure</title>
	<para>
	The creation procedure of the class creates all the needed widgets, such as checkboxes, slidebars or panels, and specifies their position, color 
	and properties. If necessary, it subscribes a feature in the appropriate event handler.
	Moreover, it creates an instance of the <classname>MAP</classname> class, which is responsible for all the things that have to be done in order to visualize the map.
	</para>
	<title>Event handling</title>
	<para>
	The event handling of this class is very important as it is the link between the user input and the features of the <classname>MAP</classname> class that do the necessary 
	operation such that the visual effects take place.
	It is important to notice that the instance of the <classname>MAP</classname> class doesn't know it's scene and therefore commands are only 
	given from the scene to the map. If the map has to process information to the scene, such as the name of a marked point, the scene has to subscribe 
	to the event handler of the map and query the information.
	</para>
<toplink/>
</section>

<section id="map">
	<para>
	</para>
	<title>MAP</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	This class is the place where all the OpenGL operations are managed. It is also responsible for parsing the map XML file. 
	This means it has a reference of type MAP. Most of the OpenGL operations are realized as simple procedures. 
	Examples of such operations are things like shortest path calculation, lighting and the other options that are available to the user. 
	The whole handling of mouse and keyboard interaction is also handled here. So there are event handlers for things like zooming, 
	translation or rotation.
	</para>
	<title>Event handling</title>
	<para>
	 i) Mouse wheel:
	Controls the zooming factor.
	</para>
	<para>
	 ii) Mouse click:
	Is used to mark stations on the map.
	</para>
	<para>
	 iii) Mouse dragging:
        <itemizedlist>
            <listitem><para>
                Right mouse button: By dragging the mouse while pressing the right mouse button you are able to translate the position of the maps in the window.
            </para></listitem>
            <listitem><para>
                Left mouse button: By dragging the mouse while pressing the left mouse button you are able to rotate the map around the the origin.
            </para></listitem>
        </itemizedlist>
	</para>
	<para>
	 iv) Keyboard:
        <itemizedlist>
            <listitem><para>
                By pressing the up-/down- or left-/right- arrow keys the map will be rotated around the x- or y-axis respectively.
            </para></listitem>
            <listitem><para>
                By pressing the enter key the map will be moved back to its initial view.
            </para></listitem>
        </itemizedlist>
	</para>
	<title>Options</title>
	<para>
	 i) Show a coordinate system
	 </para>
	<para>
	 ii) Enable/Disable lighting of the map
	 </para>
	<para>
	 iii) Change the number of buildings to be displayed on the map
	 </para>
	<para>
	 iv) Highlight the traffic lines by drawing them with different heights on the map
	 </para>
	<para>
	 v) Show the shortest path between the two marked stations.
	 </para>
	<para>
	 vi) Make the buildings transparent
	</para>
<toplink/>
</section>

<section id="factories">
	<para>
	</para>
	<title>Factories:</title>
	<para>
	</para>
</section>
	
<section id="line_factory">
	<para>
	</para>
	<title>LINE_FACTORY</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	This class is a factory for creating displayable representations of <classname>TRAFFIC_LINE</classname> objects. 
	It inherits from <classname>EM_3D_OBJECT_FACTORY</classname>, which provides the necessary structures, 
	such as the feature <featurename>create_object</featurename> or <featurename>specify_object</featurename> 
	that contains the (OpenGL) commands 
	to create the object and has to be implemented.
	</para>
	<title>Building a line</title>
	<para>
	Each line segment is drawn independently, putting a circle at the beginning and the end to indicate that 
	there're stations there. Next, the polypoints list is traversed and for each two points, a rectangle of 
	width <featurename>line_width</featurename> is created. These rectangles are connected with circles again, but smaller as the ones 
	representing the stations.
	</para>
	<toplink/>
</section>

<section id="building_factory">
	<para>
	</para>
	<title>BUILDING_FACTORY</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	Similar to <classname>TRAFFIC_LINE_FACTORY</classname>, this class is responsible for creating new buildings 
	and stores the information about the different types, such as central or outlying. 
	</para>
	<title>Type of buildings</title>
	<para>
	There're three different types of buildings implemented: city_centre, central and outlying. City_centre is the most central type and its buildings consist of a cylinder, which is completed by a hemisphere. 
	Central consists of cubes with the same size as the ones that are used for outlying, but with a pyramid roof.
	As said before, the third and last type, outlying, are only mere cubes.
	</para>
	<toplink/>
</section>

<section id="building_ewer">
	<para>
	</para>
	<title>BUILDING_EWER</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	The class <classname>BUILDING_EWER</classname> is responsible for distributing buildings on the plane.
	It takes the number of buildings from the map object and places the according number 
	of buildings on the plane using a random number generator and a collision detection, 
	which checks for collisions with traffic lines. It stores the created objects (buildings) in a container 
	and provides a feature for the map object that does the necessary drawing.
	</para>
	<title>Building distribution</title>
	<para>
	First, the centre of the new building is calculated using the random number generator. 
	Next, the collision polygon is created using these coordinates. Then the feature <featurename>has_collision</featurename>
	checks for collisions with the polygons of the traffic lines that have been created in the creation procedure earlier. 
	If there're any collisions, the coordinates are discarded and new ones calculated. If not, the distance to the centre is calculated 
	and depending on this distance, a different form and height of the building is chosen. Finally, the building is set on the 
	right position and put into the container, where it is stored. 
	</para>
	<title>Adding buildings</title>
	<para>
	If the slide bar is moved and additional buildings have to be displayed, <featurename>set_building_number</featurename>
	calculates how many and calls <featurename>add_buildings</featurename>, which takes the random number generator and the 
	container of the buildings that have already been created and adds the difference to it. Similary, if less buildings should be displayed, 
	i.e. the slide bar is moved left, the container stays the same and only the feature <featurename>draw</featurename>, 
	which is essentially a loop over the container and a draw call to all the items, is changed by setting 
	a new upper limit.
	</para>
	<toplink/>
</section>

<section id="shared_constants">
	<para>
	</para>
	<title>SHARED_CONSTANTS</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	The intention of this class is to collect information that would be spread over the whole project otherwise. 
	This helps adjusting the project and makes minor changes easier, as a constant (like <featurename>line_width</featurename>
	for example) only has to be changed a single time to take effects on the whole project. 
	All classes that want to use constants or procedures from <classname>SHARED_CONSTANTS</classname> inherit from this class, 
	but do not export the iherited features so that they are not visible in the interface.
	</para>
	<title>Constants</title>
	<para>
	In addition to constants of minor importance, such as line- or window height and width, the most important one is <featurename>plane_size</featurename> that is used 
	mostly in the classes <classname>MAP</classname> and <classname>BUILDING_EWER</classname> for calculation related to the 
	distribution of buildings for example.
	</para>
	<title>map_to_gl_coords</title>
	<para>
	This query is of great importance to the project as it maps the coordinates of the XML files that vary from 0 to 1500 to the coordinates of the plane, 
	which are in the range of -plane_size/2 to +plane_size/2. 
	All coordinate transformations that have to be done, call this procedure. This makes an adjustment to new coordinates in an XML file pretty easy, 
	because only this feature would have to be changed.
	</para>
	<toplink/>
</section>

<section id="utilities">
	<para>
	</para>
	<title>Utilities:</title>
	<para>
	</para>
</section>

<section id="gl_vector">
	<para>
	</para>
	<title>GL_VECTOR</title>
    <para>
	</para>
	<para>
	The <classname>GL_VECTOR_3D</classname> and <classname>GL_VECTOR_4D</classname> functions are pretty 
	neat to pass vectors in a feature call, because they can be passed directly to the OpenGL features. Moreover, they help to simplify the source 
	code ultimately. 
	</para>
    <toplink/>
</section>

<section id="gl_light">
	<para>
	</para>
	<title>GL_LIGHT</title>
    <para>
	</para>
	<para>
	<classname>GL_LIGHT</classname> is another class that comes pretty handy, because it embeds all the information that is needed 
	to create and change a light source for a scene. Instead of calling the appropriate OpenGL functions directly, when the position or color of a 
	light has to be changed, the according feature of this class is called. This avoids calling the same OpenGL functions on and on and gives 
	the whole thing an object orientated touch.
	</para>
	<toplink/>
</section>
</chapter>
