<?xml version="1.0"?>

<!--
	description:

		"Structure of Traffic 3D front end documentation"

	copyright: ""
	license: ""
	date: "$Date:"
	revision: "$Revision:"
-->

<chapter xmlns="http://www.gobosoft.com/eiffel/gobo/documentation" id="sample/with_code">
<chapterinfo>
	<copyright>
		<year>2005</year>
		<holder>David Stefan, Valentin Wuestholz</holder>
	</copyright>
	<author>
		<firstname>David</firstname><surname>Stefan</surname>
	</author>
    <author>
		<firstname>Valentin</firstname><surname>Wuestholz</surname>
	</author>
	<!--<email>bay@inf.ethz.ch</email>-->
	<date>12. September 2005</date>
</chapterinfo>

<title>Structure of project</title>
<section id="page_index">
<title>Page Index</title>
<para>
<itemizedlist>
    <listitem><para>
    	<indexlink url="#scene">CITY_3D_SCENE</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#map">MAP</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#factories">Factories:</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#line_factory">TRAFFIC_LINE_FACTORY</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#building_factory">BUILDING_FACTORY</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#building_ewer">BUILDING_EWER</indexlink>
    </para></listitem>
     <listitem><para>
    	<indexlink url="#shared_constants">SHARED_CONSTANTS</indexlink>
    </para></listitem>
     <listitem><para>
    	<indexlink url="#utilities">Utilities</indexlink>
    </para></listitem>
</itemizedlist>
</para>
</section>

<section id="scene">
	<para>
	</para>
	<title>CITY_3D_SCENE</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	An instance of <classname>CITY_3D_SCENE</classname> is been created by the root class and called using the standard EM procedure.
	It uses the widget toolkit of the EM library to display a panel for the OpenGL visualization of the map and another 
	one used as an toolbar for the different options.
	</para>
	<title>Creation procedure</title>
	<para>
	The creation procedure of the class creates all the needed widgets, such as checkboxes, slidebars or panels, and specify their position, color 
	and properties. If necessary, it subscribes a feature in the appropriate event handler.
	Moreover, it creates an instance of the <classname>MAP</classname> class, which is responsible for all the things that have to be done in order to visualize the map.
	</para>
	<title>Event handling</title>
	<para>
	The event handling of this class is very important as it is the link between the user input and the features of the <classname>MAP</classname> class that do the necessary 
	operation such that the visual effects take place.
	It is important to notice that the instance of the <classname>MAP</classname> class doesn't know it's scene and therefore commands are only 
	given from the scene to the map. If the map has to process information to the scene, such as the name of a marked point, the scene has to subscribe 
	to the event handler of the map and query the information.
	</para>
<toplink/>
</section>

<section id="map">
	<para>
	</para>
	<title>MAP</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	This class is the place where all the OpenGL operations are managed. It is also responsible for parsing the map XML file. 
	This means it has a reference of type MAP. Most of the OpenGL operations are realized as simple procedures. 
	Examples of such operations are things like shortest path calculation, lighting and the other options that are available to the user. 
	The whole handling of mouse and keyboard interaction is also handled here. So there are event handlers for things like zooming, 
	translation or rotation.
	</para>
	<title>b.Event handling</title>
	<para>
	 i) Mouse wheel:
	Controls the zooming factor.
	</para>
	<para>
	 ii) Mouse click:
	Is used to mark stations on the map.
	</para>
	<para>
	 i) Mouse wheel:
	Controls the zooming factor.
	</para>
	<para>
	 ii) Mouse click:
	Is used to mark stations on the map.
	</para>
	<para>
	 iii) Mouse dragging:
	1.Right mouse button:
	By dragging the mouse while pressing the right mouse button you are able to translate the position of the maps in the window.
	2.Left mouse button:
	By dragging the mouse while pressing the left mouse button you are able to rotate the map around the the origin.
	</para>
	<para>
	 iv) Keyboard:
	1.by pressing the up-/down- or left-/right- arrow keys the map will be rotated around the x- or y-axis respectively.
	2.By pressing the enter key the map will be moved back to its initial view.
	</para>
	<title>Options</title>
	<para>
	 i) Show a coordinate system
	 </para>
	<para>
	 ii) Enable/Disable lighting of the map
	 </para>
	<para>
	 iii) Change the number of buildings to be displayed on the map
	 </para>
	<para>
	 iv) Highlight the traffic lines by drawing them with different heights on the map
	 </para>
	<para>
	 v) Show the shortest path between the two marked stations.
	 </para>
	<para>
	 vi) Make the buildings transparent
	</para>
<toplink/>
</section>

<section id="factories">
	<para>
	</para>
	<title>Factories</title>
	<para>
	</para>
	<title>Description</title>
		Description
	<para>
	</para>
	<toplink/>
</section>
	
<section id="line_factory">
	<para>
	</para>
	<title>Line factory</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	This class is a factory for creating displayable representations of <classname>TRAFFIC_LINE</classname> objects. 
	It inherits from <classname>EM_3D_OBJECT_FACTORY</classname>, which provides the necessary structures, 
	such as the feature <featurename>create_object</featurename> or <featurename>specify_object</featurename> 
	that states the (OpenGL) commands 
	to create the object and has to be implemented.
	</para>
	<title>Building a line</title>
	<para>
	Each line segment is drawn independently, putting a circle at the beginning and the end to indicate that 
	there're stations there. Next, the polypoints list is traversed and for each two points, a rectangle of 
	width <featurename>line_width</featurename> is created. These rectangles are connected with circles again, but smaller as the ones 
	representing the stations.
	</para>
	<toplink/>
</section>

<section id="building_factory">
	<para>
	</para>
	<title>Building factory</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	Similar to <classname>TRAFFIC_LINE_FACTORY</classname>, this class is responsible for creating new buildings 
	and stores the information about the different types, such as central or outlying. 
	</para>
	<title>Type of houses</title>
	<para>
	There're three different typ of houses implemented: city_centre, central and outlying. City_centre is the most central 
	type and its building consist of a cylinder, which is completed by a hemisphere. 
	Central consists of cubes with the same size as the one that are used for outlying, but with a pyramid roof.
	As said before, the third and last type, outlying, are only mere cubs.
	</para>
	<toplink/>
</section>

<section id="building_ewer">
	<para>
	</para>
	<title>Building ewer</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	The class <classname>BUILDING_EWER</classname> is responsible for distributing houses on the plane.
	It takes the number of buildings from the map object and places the according number 
	of houses on the plane with help of a random number generator and a collision detection, 
	which checks for collisions with metro lines. It stores the created objects (houses) in a container 
	and provides a feature for the map object that does the necessary drawings.
	</para>
	<title>Building distribution</title>
	<para>
	First, the centre of the new house is decided with help of the random generator. 
	Next, the collision polygon is created with help of these coordinates. Then the feature <featurename>has_collision</featurename>
	checks for collisions with the polygons of the metro lines that have been created in the creation procedure earlier. 
	If there're any, the coordinates are discarded and new ones decided. If not, the distance to the centre is calculated 
	and depending on this distance, a different form and height of the building is chosen. Finally, the building is set on the 
	right position and put into the container, where it is stored. 
	</para>
	<title>Adding houses</title>
	<para>
	If the slide bar is moved and additional houses have to be displayed, <featurename>set_building_number</featurename>
	calculates how many and calls <featurename>add_buildings</featurename>, which takes the random generator and the 
	container of the houses that have already been created and adds the difference to it. Similary, if less houses should be displayed, 
	i.e. the slide bar is moved left, the container stays invariant and only the feature <featurename>draw</featurename>, 
	which is essentially a loop over the container and a draw call to all the items, is changed by setting 
	a new upper limit.
	</para>
	<toplink/>
</section>

<section id="shared_constants">
	<para>
	</para>
	<title>Shared constants</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	The intention of this class is to collect information that would be spread over the whole project otherwise. 
	This helps adjusting the project and makes minor changes easier, as a constant (like <featurename>line_width</featurename>
	for example) only has to be changed a single time to take effects on the whole project. 
	All classes that want to use constants or procedures from <classname>SHARED_CONSTANTS</classname> inherit from this class, 
	but do not export them so that the inherited features are not visible in the interface.
	</para>
	<title>Constants</title>
	<para>
	In addition to constants of minor importance, such as line- or window height and width, the most important one is <featurename>plane_size</featurename> that is used 
	mostly in the classes <classname>MAP</classname> and <classname>BUILDING_EWER</classname> for calculation related to the 
	distribution of houses for example.
	</para>
	<title>map_to_gl_coords</title>
	<para>
	This query is of great importance to the project as it maps the coordinates of the XML files that vary from 0 to 1500 to the coordinates of the plane, 
	which are in the range of -plane_size/2 to +plane_size/2. 
	All coordinate transformation that have to be done, call this procedure. This makes an adjustment to new coordinates in an XML file pretty easy, 
	because only this feature would have to be changed.
	</para>
	<toplink/>
</section>

<section id="utilities">
	<para>
	</para>
	<title>Utilities</title>
	<para>
	</para>
	<title>GL_VECTOR</title>
	<para>
	The <classname>GL_VECTOR_3D</classname> and <classname>GL_VECTOR_4D</classname> functions are pretty 
	neat to pass vectors in a feature call, because they can be passed  directly to the OpenGL features. Moreover, they help to simplify the source 
	code ultimately. 
	</para>
	<title>GL_LIGHT</title>
	<para>
	<classname>GL_LIGHT</classname> is another class that comes pretty handy, because it embeddes all the information that is needed 
	to create and change a  light source for a scene. Instead of calling the appropriate OpenGL functions directly, when the position or color of a 
	light has to be changed, the according feature of this class is called. This avoids calling the same OpenGL functions on and on again and gives 
	the whole thing an object orientated  touch.
	</para>
	<toplink/>
</section>
</chapter>
