<?xml version="1.0"?>

<!--
	description:

		"Structure of the Traffic 3D front end documentation"

	copyright: ""
	license: ""
	date: "$Date:"
	revision: "$Revision:"
-->

<chapter xmlns="http://www.gobosoft.com/eiffel/gobo/documentation" id="sample/with_code">
<chapterinfo>
	<copyright>
		<year>2005</year>
		<holder>Michela Pedroni</holder>
	</copyright>
	<author>
		<firstname>Michela</firstname><surname>Pedroni</surname>
	</author>
    <email>michela.pedroni@inf.ethz.ch</email>
	<date>12. September 2005</date>
</chapterinfo>

<title>Structure of the project</title>
<section id="page_index">
<title>Page Index</title>
<para>
<itemizedlist>
    <listitem><para>
    	<indexlink url="#scene">CITY_3D_SCENE</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#map">MAP</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#building_ewer">BUILDING_EWER</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#shared_constants">SHARED_CONSTANTS</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#factories">Factories:</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#traffic_line_factory">TRAFFIC_LINE_FACTORY</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#building_factory">BUILDING_FACTORY</indexlink>
    </para></listitem>
     <listitem><para>
    	<indexlink url="#utilities">Utilities:</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#gl_vector">GL_VECTOR</indexlink>
    </para></listitem>
    <listitem><para>
    	<indexlink url="#gl_light">GL_LIGHT</indexlink>
    </para></listitem>
</itemizedlist>
</para>
</section>

<section id="scene">
	<para/>
	<title>CITY_3D_SCENE</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	An instance of <classname cluster="city_3d">CITY_3D_SCENE</classname> gets created by the root class and called using the standard EM procedure. 
	It uses the widget toolkit of the EM library to display a panel for the OpenGL visualization of the map and another one used as a toolbar for the different options.
	</para>
	<title>Creation procedure</title>
	<para>
	The creation procedure of the class creates all the needed widgets, such as checkboxes, slidebars or labels, and specifies their position, color 
	and properties. If necessary, it subscribes a feature in the appropriate event handler.
	Moreover, it creates an instance of the <classname cluster="city_3d">MAP</classname> class, which is responsible for all the things that have to be done in order to visualize the map.
	</para>
	<title>Event handling</title>
	<para>
	The event handling of this class is very important as it is the link between the user input and the features of the <classname cluster="city_3d">MAP</classname> class that do the necessary 
	operations such that the visual effects take place.
	It is important to notice that the instance of the <classname cluster="city_3d">MAP</classname> class doesn't know it's scene and therefore commands are only 
	given from the scene to the map. If the map has to process information to the scene, such as the name of a marked point, the scene has to subscribe 
	to the event handler of the map and query the desired information.
	</para>
<toplink/>
</section>

<section id="map">
	<para/>
	<title>MAP</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	This is the main class of the project and has three main tasks. First provides features for parsing the map XML file. 
	Secondly, it is responsible for drawing the whole map with its lines, buildings, etc. This includes creating the necessary factories and drawing the map according to the enabled options. Last, it handles the user input. This means it has event handlers that change properties like zooming, translation or rotation.
	</para>
	<title>Event handling</title>
	<para>
	 i) Mouse wheel:
	Controls the zooming factor, whereas the position stays invariant. There are two different zooming speeds depending on the distance to the plane.
	</para>
	<para>
	 ii) Mouse click:
	Is used to mark stations on the map. The origin can be marked with the left mouse button, the destination with the right one. If the user clicks on an empty spot,
	the marked stations are revoked.
	</para>
	<para>
	 iii) Mouse dragging:
        <itemizedlist>
            <listitem><para>
                Left mouse button: By dragging the mouse while pressing the left button one is able to translate the position of the map in the window, i.e.
		move the plane.
            </para></listitem>
            <listitem><para>
                Right mouse button: By dragging the mouse while pressing the right button one is able to rotate the map around the the origin.
            </para></listitem>
        </itemizedlist>
	</para>
	<para>
	 iv) Keyboard:
        <itemizedlist>
            <listitem><para>
                By pressing the up-/down- or left-/right- arrow keys the map will be rotated around the x- or y-axis respectively.
            </para></listitem>
            <listitem><para>
                By pressing the enter key the translation will be reset to its initial value. However, zoom as well as rotation aren't affected.
            </para></listitem>
        </itemizedlist>
	</para>
	<title>Options</title>
	<para>
	 i) Show a coordinate system: This shows a coordinate system at the origin for better orientation.
	 </para>
	<para>
	 ii) Change lighting of the map: Initially, the scene is lit by a constant light coming down the y axis. 
	 However, this can be changed to a variable light that tries to imitate the effect of the sun.
    </para>
	<para>
	 iii) Change the number of buildings to be displayed on the map: The number of buildings can be varied from 150 up to 15000. 
	 They are randomly distributed using an instance of class <classname cluster="city_3d">BUILDING_EWER</classname>.
    </para>
	<para>
	 iv) Highlight the traffic lines by drawing them with different height on the map, in order to achieve a better overview.
    </para>
	<para>
	 v) Show the shortest path between two marked stations and display it as a white line.
    </para>
    <para>
	 vi) Take a traffic line ride from a first-person perspective between two marked stations.
	</para>
	<para>
	 vii) Make the buildings transparent in order to achieve a better overview.
	</para>
<toplink/>
</section>

<section id="building_ewer">
	<para/>
	<title>BUILDING_EWER</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	The class <classname cluster="city_3d">BUILDING_EWER</classname> is responsible for distributing buildings on the plane.
	It takes the number of buildings from the map and places the according number 
	of buildings on the plane using a random number generator and a collision detection, 
	which checks for collisions with traffic lines. It stores the created objects (buildings) in a container 
	and provides a feature to the map object that does the necessary drawing.
	</para>
	<title>Building distribution</title>
	<para>
	First, the centre of the new building is calculated using the random number generator. 
	Next, the collision polygon is created with these coordinates. Then the feature <featurename>has_collision</featurename>
	checks for collisions with the polygons of the traffic lines that have been created earlier in the creation procedure. 
	If there are any collisions, the coordinates are discarded and new ones calculated. If not, the distance to the centre is calculated and the building created using the factory and a gauger of your choice. Finally, the building is set to the right position and put into the container where it is stored. 
	</para>
	<title>Adding buildings</title>
	<para>
	If the slidebar is moved and additional buildings have to be displayed, <featurename>set_building_number</featurename>
	calculates how many and calls <featurename>add_buildings</featurename>, which takes the random number generator and the 
	container of the buildings that have already been created and adds the difference to it. Similarly, if less buildings should be displayed, 
	i.e. the slidebar is moved left, the container stays the same and only the feature <featurename>draw</featurename>, 
	which is essentially a loop over the container and a draw call to all the items, is changed by setting 
	a new upper limit.
	</para>
	<toplink/>
</section>

<section id="shared_constants">
	<para/>
	<title>SHARED_CONSTANTS</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	The intention of this class is to collect information that would be spread over the whole project otherwise. 
	This helps adjusting the project and makes minor changes easier, as a constant (like <featurename>line_width</featurename>) only has to be changed a single time to take effects on the whole project. 
	All classes that want to use constants or procedures from <classname cluster="city_3d">SHARED_CONSTANTS</classname> inherit from this class, 
	but do not export the inherited features so that they are not visible in the interface.
	</para>
	<title>Constants</title>
	<para>
	In addition to constants of minor importance, such as line-/window- height and width, the most important one is <featurename>plane_size</featurename> which is used 
	mostly in the classes <classname cluster="city_3d">MAP</classname> and <classname cluster="city_3d">BUILDING_EWER</classname> for calculations related to the 
	distribution of buildings and other issues.
	</para>
	<title>map_to_gl_coords</title>
	<para>
	This query is of great importance to the project as it maps the coordinates in the XML files that vary from 0 to 1500 to the coordinates of the plane, 
	which are in the range of -plane_size/2 to +plane_size/2. 
	All coordinate transformations that have to be done call this procedure. This makes an adjustment to new coordinates in an XML file pretty easy, 
	because only this feature would have to be changed.
	</para>
	<toplink/>
</section>

<section id="factories">
	<para/>
	<title>Factories:</title>
	<para>
	</para>
</section>
	
<section id="traffic_line_factory">
	<para>
	</para>
	<title>TRAFFIC_LINE_FACTORY</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	This class is a factory for creating displayable representations of <classname cluster="traffic">TRAFFIC_LINE</classname> objects. 
	It inherits from <classname cluster="em.video.object_factory">EM_3D_OBJECT_FACTORY</classname> which provides the necessary structures such as the feature <featurename>create_object</featurename> or <featurename>specify_object</featurename>. <featurename>specify_object</featurename> contains the (OpenGL) commands to create the object and has to be implemented. To actually create and draw an object, the feature <featurename>create_object</featurename> of the factory is called, which returns a <classname cluster="em.video">EM_3D_OBJECT</classname>. Then, the origin and scale of this object is set and the feature <featurename>draw</featurename> of the object is called.
	</para>
	<title>Building a line</title>
	<para>
	Each line segment is drawn independently, putting a circle at the beginning and the end to indicate that 
	there are stations. Next, the 'polypoints' list is traversed and for each two points a rectangle of 
	width <featurename>line_width</featurename> is created. These rectangles are connected with circles again, but smaller as the ones representing the stations.
	</para>
	<toplink/>
</section>

<section id="building_factory">
	<para/>
	<title>BUILDING_FACTORY</title>
	<para>
	</para>
	<title>Description</title>
	<para>
	Similarly to <classname cluster="city_3d">TRAFFIC_LINE_FACTORY</classname>, this class is responsible for creating new buildings. You can add to <classname cluster="city_3d">BUILDING_FACTORY</classname> object new kinds of buildings and procedures that decide about the kind of building that should be created.
	</para>
	<title>Types of buildings and decision process</title>
	<para>
	Initially, <classname cluster="city_3d">TRAFFIC_LINE_FACTORY</classname> has no information about what kind of buildings there are and how to draw them. It has two containers, <featurename>building_templates</featurename> for drawing and <featurename>gaugers</featurename> for 'decision taking procedures'. Therefore, the object that wants to create buildings using an object of this class, can pass it his own drawing and 'decision taking procedures'. Then it may <featurename>take_decision</featurename>, giving it the name of the desired gauger and his parameters. Then this gauger decides by the means of his parameters which type of building to draw and stores his decision. That's how the factory knows what kind of building to draw if <featurename>create_object</featurename> is called later.
	This modus operandi garantees maximum flexibility.
	</para>
	<toplink/>
</section>

<section id="utilities">
	<para/>
	<title>Utilities:</title>
	<para>
	</para>
</section>

<section id="gl_vector">
	<para/>
	<title>GL_VECTOR</title>
    <para>
	</para>
	<para>
	The <classname cluster="city_3d.tools">GL_VECTOR_3D</classname> and <classname cluster="city_3d.tools">GL_VECTOR_4D</classname> functions are pretty 
	neat in order to pass vectors in a feature call, because they can be directly passed to the OpenGL procedures. Moreover, this simplifies the source code.
	</para>
    <toplink/>
</section>

<section id="gl_light">
	<para/>
	<title>GL_LIGHT</title>
    <para>
	</para>
	<para>
	<classname cluster="city_3d.tools">GL_LIGHT</classname> is another class that comes in pretty handy, because it embeds all the information that is needed 
	to create and change a light source for a scene. Instead of calling the appropriate OpenGL procedures directly, when the position or color of a 
	light has to be changed, the according feature of this class is called. This avoids calling the same OpenGL functions again and again and gives 
	the whole thing an object orientated touch.
	</para>
	<toplink/>
</section>
</chapter>
