<?xml version="1.0" encoding="UTF-8"?>
<!--
	description:

		"Developer guide for Flat Hunt"

	copyright: "Copyright (c) 2005, Ursina Caluori"
	license: "Eiffel Forum License v2 (see forum.txt)"
	date: "$Date $"
	revision: "$Revision $"
-->
<chapter xmlns="http://www.gobosoft.com/eiffel/gobo/documentation" id="developer_guide/states">
    <chapterinfo>
        <copyright>
            <year>2005</year>
            <holder>Ursina Caluori</holder>
        </copyright>
        <author>
            <firstname>Ursina</firstname>
            <surname>Caluori</surname>
        </author>
        <email>ucaluori@student.ethz.ch</email>
        <date>6 August 2005</date>
    </chapterinfo>
    <title>Chapter 4: Guided "Walk-Through"</title>
    <para> What happens when you start <projectname>Flat Hunt</projectname>? In this last chapter we
        will go step-by-step through a typical <projectname>Flat Hunt</projectname> game. However,
        because there are lots of details involved, we concentrate on the more important steps… </para>
    <para>
        <orderedlist>
            <listitem>
                <para> At the very beginning, the application has to be launched. By calling
                        <featurename>make_and_launch</featurename> of class
                        <classname>FLAT_HUNT_APPLICATION</classname> exactly that is achieved. This
                    feature sets the application name, resolution and several other options and then
                    launches the first scene to be displayed, which is a
                    <classname>START_MENU_SCENE</classname>. </para>
            </listitem>
            <listitem>
                <para> When <keyword>start game</keyword> is selected in this scene,
                        <featurename>start_callback</featurename> in
                    <classname>START_MENU_SCENE</classname> is called and creates a game with the
                    proper settings and a game scene, whose job it is to visualize the game.
                        <featurename>start_callback</featurename> also calls
                        <featurename>initialize_with_game_and_scene</featurename> and
                        <featurename>start_game</featurename>, both of which belong to
                        <classname>MAIN_CONTROLLER</classname>. </para>
            </listitem>
            <listitem>
                <para>
                    <featurename>start_game</featurename> in class
                    <classname>MAIN_CONTROLLER</classname> calls
                    <featurename>create_players</featurename> as well as
                    <featurename>start_game</featurename> of class <classname>GAME</classname>.
                    Those create the players using class <classname>PLAYER_FACTORY</classname> and
                    set the game state to <keyword>Prepare_state</keyword>. </para>
            </listitem>
            <listitem>
                <para> In class <classname>PLAYER_FACTORY</classname>, for example the estate agent
                    is created using <featurename>estate_agent.make</featurename> in feature
                        <featurename>build_players</featurename>. </para>
            </listitem>
            <listitem>
                <para> This creates a <classname>HUMAN</classname>,
                    <classname>FLAT_HUNTER_BOT</classname> or
                    <classname>ESTATE_AGENT_BOT</classname> brain depending on the value of
                        <featurename>flat_hunters_bot</featurename> or
                    <featurename>estate_agent_bot</featurename> respectively, which are boolean
                    values to indicate if a human or the computer is going to play the corresponding
                    player(s). </para>
            </listitem>
            <listitem>
                <para> Back to class <classname>MAIN_CONTROLLER</classname>: Feature
                        <featurename>idle_action</featurename> gets called whenever nothing is going
                    on, i.e. now. <featurename>idle_action</featurename> checks whether the game is
                    in one of the three game loop states, and calls the corresponding feature in
                    class <featurename>MAIN_CONTROLLER</featurename>. In the first run, this is
                        <featurename>prepare</featurename>… </para>
            </listitem>
            <listitem>
                <para> …which centers the city map on <featurename>game.current_player</featurename>
                    and then calls <featurename>game.prepare</featurename>. </para>
            </listitem>
            <listitem>
                <para>
                    <featurename>prepare</featurename> of class <classname>GAME</classname> first
                    calculates the estate agent's possible moves. If there are no possible moves
                    (i.e. <featurename>current_player.possible_moves.is_empty</featurename>) then
                    it's either the next player's turn or the state is set to
                        <featurename>Agent_stuck</featurename>. Otherwise the game state is set to
                        <keyword>Play_state</keyword>. </para>
            </listitem>
            <listitem>
                <para> With that, the call to prepare (Step 6) comes to an end and control goes back
                    to feature <featurename>idle_action</featurename> of class
                        <classname>MAIN_CONTROLLER</classname>. According to the present game state,
                        <featurename>idle_action</featurename> will now call
                    <featurename>play</featurename> which then calls
                    <featurename>game.play</featurename>. </para>
            </listitem>
            <listitem>
                <para> This calls <featurename>current_player.play
                        (<argument>selected_place</argument>)</featurename>, where
                        <argument>selected_place</argument> is the last place the user clicked on.
                        <argument>selected_place</argument> is then passed on to class
                        <classname>BRAIN</classname>. </para>
            </listitem>
            <listitem>
                <para>
                    <featurename>choose_move</featurename> in class <classname>PLAYER</classname> is
                    deferred, which means that <featurename>choose_move</featurename> of class
                        <classname>ESTATE_AGENT</classname> or <classname>FLAT_HUNTER</classname>
                    gets called, depending on whether the current player is a hunter or an agent.
                </para>
            </listitem>
            <listitem>
                <para> 
                    This calls <featurename>brain.choose_move</featurename>, where <featurename>brain</featurename> is
                    either a <classname>FLAT_HUNTER_BRAIN</classname>, <classname>ESTATE_AGENT_BRAIN</classname> or
                    <classname>HUMAN</classname>.
                </para>
            </listitem>
            <listitem>
                <para>
                    The next move is now chosen, and thus the player moves. Control goes back to <featurename>idle_action</featurename>
                    and we are back at step 6. 
                </para>
            </listitem>
        </orderedlist>
    </para>
</chapter>
