
\paragraph{}
During the re-design of \emph{Flat Hunt} I stumbled upon several tricky issues that had to be dealt with. The more memorable and important ones are described in this chapter. So, here goes..

\subsection{\label{scenes_decision}Singleton Scenes vs. \texttt{last\_scene} vs. no such thing}
\begin{description}
  \item[Singleton scenes:] A class \texttt{SHARED\_SCENES} would provide singleton access to all necessary scenes of the game.
  \item[\texttt{last\_scene}:] Each scene in the game would have an attribute \texttt{last\_scene} with which you could return to the previously run scene. This obviously only works if the scenes' order of appearance has a tree structure.
  \item[No such thing:] You have none of the above. Everytime you change to another scene, a new scene is created.
\end{description}
At the very beginning I was going to use singleton scenes. The main problem was, that when you switch to another scene and then come back to a scene already run once, its events are trying to initialize a second time which leads to assertion violations. I tried to overcome this obstacle, but to no avail. I have to admit though, since this was not imperative in my opinion, I maybe didn't try hard enough. Anyway, this problem was also the reason for dropping the \texttt{last\_scene} approach and finally going back to our good old create-scenes-like-crazy-buddy. Whereas the ``like-crazy'' part might be just slightly over the top, since in \emph{Flat Hunt} you really only have three scenes and you switch very rarely. These thoughts are the reason I finally decided to give up on the more beautiful solutions and be old-fashioned for once.

\subsection{Menu Design}
Basically there were three options I took into consideration:

\begin{description}
  \item[1.] Having a class \texttt{MENU} which contains a list of strings (\texttt{EM\_STRING}s to be exact, but could also be generalized to be \texttt{EM\_DRAWABLE}s) that represent the entries. Along with that you would have to store which entry is currently selected. Then you would also need an \texttt{on\_select} - procedure that makes a case distinction based on \texttt{selected\_entry} and reacts accordingly. Something like the following: 
    \begin{lstlisting}
class
	MENU
...
feature
	entries: ARRAYED_LIST [EM_DRAWABLE]
	
	selected_entry: INTEGER

    \end{lstlisting}
    \begin{lstlisting}
class
	MENU_SCENE
...
feature
	menu: MENU
	
	on_select is
		do
			if menu.selected_entry = 1 then
				-- Do what entry 1 says, e.g. start a new game.
	  		elseif menu.selected_entry = 2 then
				-- Do what entry 2 says, e.g. show the credits.
			elseif ...
				...
			end
		end
	...
    \end{lstlisting}
  \item[2.] Pretty much the same setup as in case 1, but additionally class \texttt{MENU} would contain a list of agents with each agent corresponding to a menu entry. And \texttt{on\_select} were to be moved from \texttt{MENU\_SCENE} to \texttt{MENU}.
    \begin{lstlisting}
class
	MENU
...
feature
	entries: ARRAYED_LIST [EM_DRAWABLE]
	selected_entry: INTEGER
	agents: ARRAYED_LIST [PROCEDURE [ANY, TUPLE]]

	on_select is
		do
			agents.i_th (selected_entry).call([])
		end

    \end{lstlisting}  
    \begin{lstlisting}
class
	MENU_SCENE
...
feature
	menu: MENU
	
	make is
		do
			create menu.make
			menu.agents.extend (agent agent1)
			menu.agents.extend (agent agent2)
			...
		end
		
	agent1 is
		do
			-- Do what entry 1 says, e.g. start a new game.
		end
		
	agent2 is
		do
			-- Do what entry 2 says, e.g. show the credits.
		end
	...
	
    \end{lstlisting}

  \item[3.] Case 2 directly leads to a more beautiful solution: Having a class \texttt{MENU} which is a \texttt{EM\_DRAWABLE\_CONTAINER [EM\_DRAWABLE]} that contains all menu entries, which are of type \texttt{MENU\_ENTRY}, whereas each menu entry has its callback (i.e. agent) as an attribute. The beauty of this approach is its pure object-orientedness as opposed to the previous two.
    \begin{lstlisting}
class
	MENU_ENTRY
inherit
	EM_DRAWABLE_CONTAINER [EM_DRAWABLE]
...
feature
	callback: PROCEDURE [ANY, TUPLE]
	text: EM_STRING
	...
	
	call is
		do
			if callback /= Void then
				callback.call ([])
			end
		end
	
    \end{lstlisting}    
    \begin{lstlisting}
class
	MENU
inherit
	EM_DRAWABLE_CONTAINER [MENU_ENTRY]
...
feature
	selected_entry: INTEGER
	
	add_entry (a_text: STRING; a_callback: PROCEDURE [ANY, TUPLE]) is
		do
			create_a_menu_entry_with_a_text
			created_menu_entry.set_callback (a_callback)
			extend (created_menu_entry)
		end
	
	on_select is
		do
			if i_th (selected_entry).callback /= Void then
				item (selected_entry).call
			end
		end
      
    \end{lstlisting}
    \begin{lstlisting}
class
	MENU_SCENE
...
feature
	menu: MENU
	
	make is
		do
			create menu.make
			menu.add_entry (``Entry 1'', agent agent1)
			menu.add_entry (``Entry 2'', agent agent2)
			...
		end

	agent1 is
		do
			-- Do what entry 1 says, e.g. start a new game.
		end
	
	agent2 is
		do
			-- Do what entry 2 says, e.g. show the credits.
		end
	...		
    \end{lstlisting}
\end{description}

Originally I wanted to implement the first version, albeit the most abominable one, because it seemed to me to be the straight-forward approach (I don't have a very strong object-oriented programming background - or now it is perhaps more appropriate to say I didn't have, because I learned an awful lot by working on this project..). But soon I started thinking it was kind of ugly, so I thought of other solutions and came up with the second and third option. Frankly, I wasn't so sure at this point which one to use, but after discussing the matter with Michela, I finally opted for the third one (which now appears to me should have been the logical choice from the start - but that's just the beauty of hindsight, I guess..).

\subsection{Main Controller Necessary?}
In the old version of \emph{Flat Hunt} a \texttt{MAIN\_CONTROLLER} controlled how the game logic and the visualization worked together. I was not so sure if the main controller was really a necessity, because it seemed to be just as reasonable and also easier to implement if the visualization was directly in contact with the logic behind and got the information on what to display when from there. And also because a \texttt{EM\_SCENE} is not strictly a visualization tool but includes an event loop, which means it is some kind of visualization / control hybrid. So, did I really need some third party controlling unit if my scene can already take care of that?\\
After some contemplation I came to realize that I did indeed need just that, in order to maintain a clear distinction of the \emph{View} and \emph{Controller} clusters (see \autoref{dg_design}), i.e. between visualization and control. 

\subsection{\texttt{PLAYER} and \texttt{PLAYER\_DISPLAYER}}
I had a pretty rough time figuring out how exactly to handle this separation. The main problem was not dividing the model and the view features but more about the question ``Who is in charge?''. I didn't want to have a two-way dependency, because I was told that was bad design. So I could either have a player which has a player displayer as attribute or the other way around. The logical choice would be to have a player displayer with a player as attribute (which I also chose in the end), because the player displayer visualizes a player and therefore has to know him. In my first design though, I couldn't eliminate the need for the player to know the displayer. That was until I discovered the \textit{draw} feature of \texttt{EM\_DRAWABLE}s. My original displayer was an \texttt{EM\_DRAWABLE\_CONTAINER [EM\_DRAWABLE]}, and there you don't necessarily have to write your own \textit{draw} procedure (you can, though), you just throw everything that needs to be drawn in the container. The problem with this is that you can't make conditional draws, meaning you have to tell the displayer from the outside when to draw what, so the player needed to inform the displayer about what he wants to get drawn and what not. As I said, my attempts to eliminate the two-way dependency this way failed miserably, so I thought I'd try it the other way around - which obviously was another failure (fortunately it didn't take me long to figure that out). So then I did a little more research into \emph{EM} and discovered above-mentioned \textit{draw} feature, which worked like a charm and finally allowed me to have my desired one-way dependency.

\subsection{Necessity of \texttt{FLAT\_HUNT\_SCENE}}
A \texttt{FLAT\_HUNT\_SCENE} inherits directly from \texttt{EM\_SCENE}. This class was my prototype for a scene which supports the \texttt{last\_scene} approach described in \autoref{scenes_decision}, but since I decided against that option, this scene was useless for some time. Until, one day, I implemented a little music player and I wanted it to be a shared music player, so that the songs play on as scenes are switched, and the controls are the same in every scene. That literally called for a \texttt{FLAT\_HUNT\_SCENE}, which is why I dug it out again but changed it profoundly. What is left is a scene that supports a shared music player and its controls. And because that is exactly what I wanted, \texttt{FLAT\_HUNT\_SCENE} is a survivor after all..

